0. java 문법

### 1. 숫자 및 문자열 reverse

숫자라면 String으로 바꿈 : Integer.toString(숫자);
문자열이된 것을 StringBuilder sb = new StringBuilder(문자열);
문자열.equals(sb.reverse().toString) 으로 reverse해도 같은지 비교
-> 팰린드롬 : 101, lol 등

### 2. 소수 구하기

소수는 1과 자기자신을 제외한 숫자로 나눴을때 나누어 떨어지지 않는 숫자
자신까지 for문 돌면서 % =0 으로 확인가능,
순열-> 3개중 2개 , 4개중3개 선택 문제 -> dfs

### 3. list의 contains

list.contains( ) -> 있으면 true 없으면 false list에 아무값이 없어도 사용가능
재정의도 가능

배열은 contains x -> Arrays.asList(배열).contains(()

```
public class Product {
    int id;
    String name;
    public Product(int id, String name) {
        this.id = id;
        this.name = name;
        }
    @Override
    public boolean equals(Object object) {
        Product product = (Product) object;         // name은 상관없이, id만 같으면 true를 리턴합니다.
        if (product.id == this.id) {
            return true;
            }
        return false;
        }
}
```

### 4. Map 정의 및 key또는 value로 sort

key를 배열로 만들고 key sort해서 get

Map<Integer,Character> map = new HashMap<>();
Object[] mapkey = map.keySet().toArray();
Array.sort(mapkey);
for(Integer key : mapkey.keySet()){
map.get(key)k;
}
map.containsKey();

### 5. 문자열정렬

char[] A = 문자열.toCharArray();
Arrays.sort(A);
문자열 = new String(A);

### 6. Comparator

Collections.sort(list, )
Arrays.sort(배열, new Comparator<String>(){
@Override
public int compare(String A, String B){
return A.compareTo(B);
}
})

```
int[][] routes;
Arrays.sort(routes, new Comparator<int[]>(){
    @Override
    public int compare(int[] route1, int[] route2){
    return route1[1] - route2[1];
    }
});
```

### 7. String compareTo

문자열.compareTo(문자열); -> 오름차순

### 8. Map 전체출력

Map<String, Character> map = new HashMap<>();
for(String key : map.keySet()){

}

### 9. Map sort 출력

Map<Character, Integer> map = new HashMap<>();
Object[] mapkey = map.keySet().toArray();
Arrays.sort(mapkey);

### 10. Map 다루기

map.put(key,value);
map.containsKey();
map.containsValue();
map.keySet()
map.getOrDefault(key,defaultValue)
map.get(key)
map.replace(key,value)
map.keySet().toArray(new key타입[map.size()]);

### 11. 문자열을 찾아서 replaceAll

```
import java.util.*;
class Solution {
    public int solution(String s) {
        String[] array = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
        for(int i = 0 ; i < array.length ; i++){
            if(s.contains(array[i]))
                s = s.replaceAll(array[i],Integer.toString(i));
            }
            int answer = Integer.parseInt(s);
            return answer;
        }



    }
```

### 12. stack

```
Stack<> stack = new Stack<>();
stack.push();
stack.pop();
```

### 13. 문자열 분리

1. split
   문자열.split(",");
2. substring()
   문자열.substring(포함,불포함);

### 14. max min

Collections.max();
Array는 없음 배열 돌면서 max 찾아야함

### 15. Set

```
set.add();
set.size();

Iterator<데이터타입> iterator명 = set명.Iterator();
while(iterator명.hasNext()) {
iterator명.next(); // 값 없을때까지 계속 출력
}
```

### 16. String to charArray

char[] A = 문자열.toCharArray();

### 17. charArray to String

char[] A = {'a','b'};
String B = new String(A);

### 18. char to String

String str = String.valueOf('d');

### 19. char to int

int A = char - '0';

### 20. 아스키코드

0 -> 48
9 -> 57

### 21. int to char

int A = 1;
char B = (char)(A+'0');

### 22. int to float or float to int

int A = (int)float
float B = (float)

### 23. 공백 split

split은 String을 String 배열로 자른다.
문자열.split("\\s");

### 24. 문자열 upper, lower

문자열. toUpperCase();
toLowerCasd();

### 25. 문자 upper, lower

Character.toUpperCase('');

### 26. Collection type

Queue등 Character로 사용

### 27. int를 2진수,8진수 16진수로 바꾸기

```
String binaryString = Integer.toBinaryString(i); //2진수
String octalString = Integer.toOctalString(i);   //8진수
String hexString = Integer.toHexString(i);
```

### 28. 바로 배열 return

```
return new int[]{1,2};
```

### 29. map의 key, value를 list,array로

keySet()
key를 array로 만들어서 정렬
Object[] array = map.keySet().toArray();
Arrays.sort(array);
List<key타입> list = new ArrayList<>(map.keySet());

values()
value를 array or list로 만들어서 정렬
List<value타입>list = new ArrayList<>(map.values());
Collections.sort(list,Collections.reverseOrder());

entrySet()
List<Entry<key타입,value타입>> list = new ArrayList<Entry<key타입,value타입>>(map.entrySet());

### 30. 비트마스킹

1. 비트 연산자
   &(and) 대응하는 두 비트가 모두 1일 때 1반환
   |(or) 대응하는 두 비트 중 하나라도 1이라면 1을 반환, 아니면 0반환
   ^(xor) 대응하는 두 비트가 다르면 1, 같으면 0을 반환
   ~(not) 비트의 값을 반전

   > > ,<<(shift) 오른쪽, 왼쪽으로 비트를 이동

2. 비트 연산
   원소 추가 : s = s | (1<<k); -> k번째 비트마스킹하고 s와 or연산을 통해서 s의 k번째 비트가 없다면 추가해주는 연산
   원소 삭제 : s = s & ~(1<<k); -> k번째 비트마스킹하고 not연산을 통해서 k번째를 제외한 모든 연산을 1로 만들어준다. 그 뒤에 k번째가 0인 값과 and연산을 실행하면 해당 k번째는 무조건 0으로 바뀜
   원소 확인 : s&(1<<k); -> k번째를 1로 만들고 and연산을 실행하면 s의 k번째가 1이면 1을 return, 0이면 0을 return
   원소 토글 : s = s^(1<<k); -> k번째를 1로 만들고 xor연산을 하면 1과 같으면 0, 1과 다르면 1을 return하기 때문에 비트가 토글된다
   원소 채우기 : s = (1<<k+1)-1 -> k+1번째를 1로 만들고 -1을 하면 k번째 까지 1로 채운게 된다.
